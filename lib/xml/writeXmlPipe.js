// Generated by CoffeeScript 1.3.1
(function() {
  var WriteXmlPipe, builder, sdmx, stringifiers, util,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  sdmx = require('../pipe/sdmxPipe');

  builder = require('xmlbuilder');

  util = require('util');

  stringifiers = {
    toString: function(doc) {
      return doc.toString({
        pretty: true
      });
    },
    intString: {
      v2_1: function(doc, obj, type) {
        var key, value, _results;
        if (obj == null) {
          return;
        }
        _results = [];
        for (key in obj) {
          value = obj[key];
          _results.push(doc.ele(type).att('xml:lang', key).txt(value));
        }
        return _results;
      }
    },
    maintainable: {
      v2_1: function(doc, obj) {
        var id;
        id = doc.att('id', obj.id).att('agencyID', obj.agencyID);
        if (obj.version != null) {
          id.att('version', obj.version);
        }
        if (obj.isFinal != null) {
          id.att('isFinal', obj.isFinal);
        }
        return stringifiers.intString.v2_1(doc, obj.name, 'Name');
      }
    },
    item: {
      v2_1: function(doc, obj) {
        doc.att('id', obj.id);
        return stringifiers.intString.v2_1(doc, obj.name, 'Name');
      }
    },
    itemScheme: {
      v2_1: function(doc, obj) {
        stringifiers.maintainable.v2_1(doc, obj);
        if (obj.isPartial != null) {
          return doc.att('isPartial', obj.isPartial);
        }
      }
    },
    urn: {
      v2_1: function(doc, obj) {
        if (obj.urn == null) {
          return;
        }
        return doc.ele('URN').txt(obj.urn);
      }
    },
    itemRef: {
      v2_1: function(doc, obj) {
        var ref;
        if (obj.ref == null) {
          return;
        }
        ref = doc.ele('Ref');
        ref.att('id', obj.ref.id).att('agencyID', obj.ref.agencyID).att('maintainableParentID', obj.ref.maintainableParentID).att('maintainableParentVersion', obj.ref.maintainableParentVersion);
        if (obj.ref["class"] != null) {
          ref.att('class', obj.ref["class"]);
        }
        if (obj.ref["package"] != null) {
          return ref.att('package', obj.ref["package"]);
        }
      }
    },
    ref: {
      v2_1: function(doc, obj) {
        var ref;
        if (obj.ref == null) {
          return;
        }
        ref = doc.ele('Ref');
        ref.att('id', obj.ref.id).att('agencyID', obj.ref.agencyID).att('version', obj.ref.version);
        if (obj.ref["class"] != null) {
          ref.att('class', obj.ref["class"]);
        }
        if (obj.ref["package"] != null) {
          return ref.att('package', obj.ref["package"]);
        }
      }
    },
    conceptIdentity: {
      v2_1: function(doc, obj) {
        var ident;
        if (obj.conceptIdentity == null) {
          return;
        }
        ident = doc.ele('ConceptIdentity');
        stringifiers.urn.v2_1(ident, obj.conceptIdentity);
        return stringifiers.itemRef.v2_1(ident, obj.conceptIdentity);
      }
    },
    localRepresentation: {
      v2_1: function(doc, obj) {
        var enume, frmt, rep;
        if (obj.localRepresentation == null) {
          return;
        }
        rep = doc.ele('LocalRepresentation');
        if (obj.localRepresentation.enumeration != null) {
          enume = rep.ele('Enumeration');
          stringifiers.urn.v2_1(enume, obj.localRepresentation.enumeration);
          stringifiers.ref.v2_1(enume, obj.localRepresentation.enumeration);
        }
        if (obj.localRepresentation.textFormat != null) {
          frmt = rep.ele('TextFormat');
          if (obj.localRepresentation.textFormat.textType != null) {
            frmt.att('textType', obj.localRepresentation.textFormat.textType);
          }
          if (obj.localRepresentation.textFormat.minLength != null) {
            frmt.att('minLength', obj.localRepresentation.textFormat.minLength);
          }
          if (obj.localRepresentation.textFormat.maxLength != null) {
            return frmt.att('maxLength', obj.localRepresentation.textFormat.maxLength);
          }
        }
      }
    },
    codelist: {
      v2_1: function(doc, obj) {
        var code, codelist, key, value, _ref;
        codelist = doc.begin('Codelist');
        stringifiers.itemScheme.v2_1(codelist, obj);
        _ref = obj.codes;
        for (key in _ref) {
          value = _ref[key];
          code = codelist.ele('Code');
          stringifiers.item.v2_1(code, value);
        }
        return stringifiers.toString(doc);
      }
    },
    conceptScheme: {
      v2_1: function(doc, obj) {
        var concept, concepts, key, value, _ref;
        concepts = doc.begin('ConceptScheme');
        stringifiers.itemScheme.v2_1(concepts, obj);
        _ref = obj.concepts;
        for (key in _ref) {
          value = _ref[key];
          concept = concepts.ele('Concept');
          stringifiers.item.v2_1(concept, value);
        }
        return stringifiers.toString(doc);
      }
    },
    dataStructureDefinition: {
      v2_1: function(doc, obj) {
        var comp, components, dsd, key, list, m, type, value, _ref, _ref1;
        dsd = doc.begin('DataStructure');
        stringifiers.maintainable.v2_1(dsd, obj);
        components = dsd.ele('DataStructureComponents');
        list = components.ele('DimensionList');
        _ref = obj.dimensionDescriptor;
        for (key in _ref) {
          value = _ref[key];
          type = (function() {
            switch (value.type) {
              case 'dimension':
                return 'Dimension';
              case 'measureDimension':
                return 'MeasureDimension';
              case 'timeDimension':
                return 'TimeDimension';
            }
          })();
          comp = list.ele(type);
          comp.att('id', value.id);
          stringifiers.conceptIdentity.v2_1(comp, value);
          stringifiers.localRepresentation.v2_1(comp, value);
        }
        list = components.ele('AttributeList');
        _ref1 = obj.attributeDescriptor;
        for (key in _ref1) {
          value = _ref1[key];
          comp = list.ele('Attribute').att('id', value.id).att('assignmentStatus', value.assignmentStatus);
          stringifiers.conceptIdentity.v2_1(comp, value);
          stringifiers.localRepresentation.v2_1(comp, value);
        }
        if (obj.measureDescriptor != null) {
          m = components.ele('MeasureList').ele('PrimaryMeasure').att('id', obj.measureDescriptor.primaryMeasure.id);
          stringifiers.conceptIdentity.v2_1(m, value);
          stringifiers.localRepresentation.v2_1(m, value);
        }
        return stringifiers.toString(doc);
      }
    },
    group: {
      genericTimeSeriesData: {
        v2_1: function(doc, obj) {
          var attributes, group, groupKey, key, value, _ref, _ref1;
          group = doc.begin('Group').att('type', obj.type);
          groupKey = group.e('GroupKey');
          _ref = obj.groupKey;
          for (key in _ref) {
            value = _ref[key];
            groupKey.ele('Value').att('value', value).att('id', key);
          }
          attributes = group.e('Attributes');
          _ref1 = obj.attributes;
          for (key in _ref1) {
            value = _ref1[key];
            attributes.ele('Value').att('value', value).att('id', key);
          }
          return stringifiers.toString(doc);
        }
      },
      structureSpecificTimeSeriesData: {
        v2_1: function(b, obj) {
          var group, key, value, _ref, _ref1;
          group = doc.begin('Group').att('xsi:type', "str:" + obj.type);
          _ref = obj.groupKey;
          for (key in _ref) {
            value = _ref[key];
            group.a(key, value);
          }
          _ref1 = obj.attributes;
          for (key in _ref1) {
            value = _ref1[key];
            group.a(key, value);
          }
          return stringifiers.toString(doc);
        }
      }
    },
    series: {
      genericTimeSeriesData: {
        v2_1: function(doc, obj) {
          var attributes, i, key, obs, series, seriesKey, t, value, _i, _len, _ref, _ref1, _ref2, _ref3;
          series = doc.begin('Series');
          seriesKey = series.e('SeriesKey');
          _ref = obj.seriesKey;
          for (key in _ref) {
            value = _ref[key];
            seriesKey.ele('Value').att('value', value).att('id', key);
          }
          if (obj.attributes != null) {
            attributes = series.e('Attributes');
            _ref1 = obj.attributes;
            for (key in _ref1) {
              value = _ref1[key];
              attributes.ele('Value').att('value', value).att('id', key);
            }
          }
          _ref2 = obj.obs.obsDimension;
          for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
            t = _ref2[i];
            obs = series.e('Obs');
            obs.ele('ObsDimension').att('value', obj.obs.obsDimension[i]);
            obs.ele('ObsValue').att('value', obj.obs.obsValue[i]);
            attributes = obs.e('Attributes');
            _ref3 = obj.obs.attributes;
            for (key in _ref3) {
              value = _ref3[key];
              attributes.ele('Value').att('value', value[i]).att('id', key);
            }
          }
          return stringifiers.toString(doc);
        }
      },
      structureSpecificTimeSeriesData: {
        v2_1: function(doc, obj) {
          var i, key, obs, series, t, value, _i, _len, _ref, _ref1, _ref2, _ref3;
          series = doc.begin('Series');
          _ref = obj.seriesKey;
          for (key in _ref) {
            value = _ref[key];
            series.a(key, value);
          }
          _ref1 = obj.attributes;
          for (key in _ref1) {
            value = _ref1[key];
            series.a(key, value);
          }
          _ref2 = obj.obs.TIME_PERIOD;
          for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
            t = _ref2[i];
            obs = series.e('Obs');
            obs.a('TIME_PERIOD', obj.obs.TIME_PERIOD[i]);
            obs.a('OBS_VALUE', obj.obs.OBS_VALUE[i]);
            _ref3 = obj.obs.attributes;
            for (key in _ref3) {
              value = _ref3[key];
              obs.a(key, value[i]);
            }
          }
          return stringifiers.toString(doc);
        }
      }
    },
    dataset: {
      genericTimeSeriesData: {
        v2_1: function(doc, obj) {
          var dataset, str;
          dataset = doc.begin('message:DataSet');
          dataset.att('xmlns', 'http://www.sdmx.org/resources/sdmxml/schemas/v2_1/generic').att('structureRef', obj.structureRef);
          if (obj.setID != null) {
            dataset.att('setID', obj.setID);
          }
          if (obj.action != null) {
            dataset.att('action', obj.action);
          }
          if (obj.reportingBeginDate != null) {
            dataset.att('reportingBeginDate', obj.reportingBeginDate.toISOString());
          }
          if (obj.reportingEndDate != null) {
            dataset.att('reportingEndDate', obj.reportingEndDate.toISOString());
          }
          if (obj.validFromDate != null) {
            dataset.att('validFromDate', obj.validFromDate.toISOString());
          }
          if (obj.validToDate != null) {
            dataset.att('validToDate', obj.validToDate.toISOString());
          }
          if (obj.publicationYear != null) {
            dataset.att('publicationYear', obj.publicationYear);
          }
          if (obj.publicationPeriod != null) {
            dataset.att('publicationPeriod', obj.publicationPeriod);
          }
          str = stringifiers.toString(doc);
          return str = str.replace(/\/>/, '>');
        }
      },
      structureSpecificTimeSeriesData: {
        v2_1: function(doc, obj) {
          var dataset, str;
          dataset = doc.begin('message:DataSet').att('xsi:type', 'str:DataSetType').att('data:structureRef', obj.structureRef);
          if (obj.setID != null) {
            dataset.att('data:setID', obj.setID);
          }
          if (obj.action != null) {
            dataset.att('data:action', obj.action);
          }
          if (obj.reportingBeginDate != null) {
            dataset.att('data:reportingBeginDate', obj.reportingBeginDate.toISOString());
          }
          if (obj.reportingEndDate != null) {
            dataset.att('data:reportingEndDate', obj.reportingEndDate.toISOString());
          }
          if (obj.validFromDate != null) {
            dataset.att('data:validFromDate', obj.validFromDate.toISOString());
          }
          if (obj.validToDate != null) {
            dataset.att('data:validToDate', obj.validToDate.toISOString());
          }
          if (obj.publicationYear != null) {
            dataset.att('data:publicationYear', obj.publicationYear);
          }
          if (obj.publicationPeriod != null) {
            dataset.att('data:publicationPeriod', obj.publicationPeriod);
          }
          if (obj.dataScope != null) {
            dataset.att('data:dataScope', obj.dataScope);
          }
          if (obj.REPORTING_YEAR_START_DAY != null) {
            dataset.att('REPORTING_YEAR_START_DAY', obj.REPORTING_YEAR_START_DAY);
          }
          str = stringifiers.toString(doc);
          return str = str.replace(/\/>/, '>');
        }
      }
    },
    parties: {
      v2_1: function(doc, obj, type) {
        var contact, key, party, value, value2, _results;
        if (obj == null) {
          return;
        }
        _results = [];
        for (key in obj) {
          value = obj[key];
          party = doc.ele(type).att('id', value.id);
          stringifiers.intString.v2_1(party, value.name, 'Name');
          if (value.contact != null) {
            _results.push((function() {
              var _i, _len, _ref, _results1;
              _ref = value.contact;
              _results1 = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                value2 = _ref[_i];
                contact = party.ele('Contact');
                if (value2.name != null) {
                  stringifiers.intString.v2_1(contact, value2.name, 'Name');
                }
                if (value2.department != null) {
                  stringifiers.intString.v2_1(contact, value2.department, 'Department');
                }
                if (value2.role != null) {
                  stringifiers.intString.v2_1(contact, value2.role, 'Role');
                }
                if (value2.telephone != null) {
                  contact.ele('Telephone').txt(value2.telephone);
                }
                if (value2.fax != null) {
                  contact.ele('Fax').txt(value2.fax);
                }
                if (value2.x400 != null) {
                  contact.ele('X400').txt(value2.x400);
                }
                if (value2.uri != null) {
                  contact.ele('URI').txt(value2.uri);
                }
                if (value2.email != null) {
                  _results1.push(contact.ele('Email').txt(value2.email));
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            })());
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    },
    header: {
      v2_1: function(doc, obj) {
        var header;
        header = doc.ele('Header').ele('ID').txt(obj.id).up().ele('Test').txt(obj.test).up().ele('Prepared').txt(obj.prepared.toISOString()).up();
        stringifiers.parties.v2_1(header, obj.sender, 'Sender');
        stringifiers.parties.v2_1(header, obj.receiver, 'Receiver');
        stringifiers.intString.v2_1(header, obj.name, 'Name');
        if (obj.dataSetAction != null) {
          header.ele('DataSetAction').txt(obj.dataSetAction);
        }
        if (obj.dataSetID != null) {
          header.ele('DataSetID').txt(obj.dataSetID);
        }
        if (obj.extracted != null) {
          header.ele('Extracted').txt(obj.extracted.toISOString());
        }
        if (obj.reportingBegin != null) {
          header.ele('ReportingBegin').txt(obj.reportingBegin);
        }
        if (obj.reportingEnd != null) {
          header.ele('ReportingEnd').txt(obj.reportingEnd);
        }
        if (obj.embargoDate != null) {
          header.ele('EmbargoDate').txt(obj.embargoDate.toISOString());
        }
        stringifiers.intString.v2_1(header, obj.source, 'Source');
        return stringifiers.toString(doc);
      }
    },
    document: {
      v2_1: function(doc, rootElemName, header) {
        var str;
        str = '<?xml version="1.0" encoding="UTF-8"?>\n';
        str += "<" + rootElemName + " ";
        str += 'xmlns="http://www.sdmx.org/resources/sdmxml/schemas/v2_1/message" ';
        str += 'xmlns:message="http://www.sdmx.org/resources/sdmxml/schemas/v2_1/message" ';
        str += 'xmlns:common="http://www.sdmx.org/resources/sdmxml/schemas/v2_1/common" ';
        str += 'xmlns:generic="http://www.sdmx.org/resources/sdmxml/schemas/v2_1/data/generic" ';
        str += 'xmlns:data="http://www.sdmx.org/resources/sdmxml/schemas/v2_1/data/structurespecific" ';
        str += 'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">\n';
        str += stringifiers.header.v2_1(doc, header);
        return str;
      }
    }
  };

  WriteXmlPipe = (function(_super) {

    __extends(WriteXmlPipe, _super);

    WriteXmlPipe.name = 'WriteXmlPipe';

    function WriteXmlPipe(log) {
      this.header = {};
      this.rootElemName = '';
      this.doc = builder.create();
      WriteXmlPipe.__super__.constructor.apply(this, arguments);
    }

    WriteXmlPipe.prototype.before = function(type, data) {
      var str;
      str = '';
      switch (type) {
        case 'header':
          this.header = data;
      }
      return str;
    };

    WriteXmlPipe.prototype.beforeFirst = function(type) {
      var str;
      str = '';
      switch (type) {
        case sdmx.CODE_LIST:
        case sdmx.CONCEPT_SCHEME:
        case sdmx.DATA_STRUCTURE_DEFINITION:
          if (this.counters["in"].structure === 1) {
            this.rootElemName = 'Structure';
            str += stringifiers.document.v2_1(this.doc, this.rootElemName, this.header);
            str += '<message:Structures xmlns="http://www.sdmx.org/resources/sdmxml/schemas/v2_1/structure">\n';
          }
          switch (type) {
            case sdmx.CODE_LIST:
              str += '<Codelists>\n';
              break;
            case sdmx.CONCEPT_SCHEME:
              str += '<Concepts>\n';
              break;
            case sdmx.DATA_STRUCTURE_DEFINITION:
              str += '<DataStructures>\n';
          }
          break;
        case sdmx.DATA_SET_HEADER:
          this.rootElemName = 'GenericTimeSeriesData';
          str += stringifiers.document.v2_1(this.doc, this.rootElemName, this.header);
          break;
        case 'end':
          if (0 < this.counters["in"].datasetheader) {
            str += '</message:DataSet>\n';
          }
          if (0 < this.counters["in"].structure) {
            str += '</message:Structures>\n';
          }
          str += "</" + this.rootElemName + ">";
      }
      return str;
    };

    WriteXmlPipe.prototype.stringify = function(type, data) {
      switch (type) {
        case sdmx.CODE_LIST:
          return stringifiers.codelist.v2_1(this.doc, data);
        case sdmx.CONCEPT_SCHEME:
          return stringifiers.conceptScheme.v2_1(this.doc, data);
        case sdmx.DATA_STRUCTURE_DEFINITION:
          return stringifiers.dataStructureDefinition.v2_1(this.doc, data);
        case sdmx.DATA_SET_HEADER:
          return stringifiers.dataset.genericTimeSeriesData.v2_1(this.doc, data);
        case sdmx.SERIES:
          return stringifiers.series.genericTimeSeriesData.v2_1(this.doc, data);
        case sdmx.ATTRIBUTE_GROUP:
          return stringifiers.group.genericTimeSeriesData.v2_1(this.doc, data);
        case sdmx.DATA_SET_ATTRIBUTES:
          return '';
        default:
          return '';
      }
    };

    WriteXmlPipe.prototype.afterLast = function(type) {
      switch (type) {
        case sdmx.CODE_LIST:
          return '</Codelists>\n';
        case sdmx.CONCEPT_SCHEME:
          return '</Concepts>\n';
        case sdmx.DATA_STRUCTURE_DEFINITION:
          return '</DataStructures>\n';
        default:
          return '';
      }
    };

    return WriteXmlPipe;

  })(sdmx.WriteSdmxPipe);

  exports.WriteXmlPipe = WriteXmlPipe;

}).call(this);
