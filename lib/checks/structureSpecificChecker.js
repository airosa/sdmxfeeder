// Generated by CoffeeScript 1.3.1
(function() {
  var Checker, StructureSpecificChecker, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  Checker = require('./checker').Checker;

  util = require('util');

  StructureSpecificChecker = (function(_super) {

    __extends(StructureSpecificChecker, _super);

    StructureSpecificChecker.name = 'StructureSpecificChecker';

    function StructureSpecificChecker(log) {
      this.write = __bind(this.write, this);
      this.schemas = {};
      StructureSpecificChecker.__super__.constructor.apply(this, arguments);
    }

    StructureSpecificChecker.prototype.getItemID = function(item) {
      return "" + item.agencyID + ":" + item.id + "(" + item.version + ")";
    };

    StructureSpecificChecker.prototype.getItemParentID = function(item) {
      return "" + item.agencyID + ":" + item.maintainableParentID + "(" + item.maintainableParentVersion + ")";
    };

    StructureSpecificChecker.prototype.addEnum = function(enumeration, target, codelists) {
      var code, codelist, codes;
      if (enumeration == null) {
        return;
      }
      codelist = codelists[this.getItemID(enumeration.ref)];
      if (codelist == null) {
        return;
      }
      codes = [];
      for (code in codelist.codes) {
        codes.push(code);
      }
      return target["enum"] = codes;
    };

    StructureSpecificChecker.prototype.addTextFormat = function(format, target) {
      if (format == null) {
        return;
      }
      target.type = (function() {
        switch (format.textType) {
          case 'Numeric':
            return 'number';
          default:
            return 'string';
        }
      })();
      if (format.minLength != null) {
        target.minLength = format.minLength;
      }
      if (format.maxLength != null) {
        return target.maxLength = format.maxLength;
      }
    };

    StructureSpecificChecker.prototype.addFromRepresentation = function(comp, target, structs) {
      var concept, conceptScheme, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      conceptScheme = structs.conceptSchemes[this.getItemParentID((_ref = comp.conceptIdentity) != null ? _ref.ref : void 0)];
      concept = conceptScheme != null ? conceptScheme.concepts[(_ref1 = comp.conceptIdentity) != null ? (_ref2 = _ref1.ref) != null ? _ref2.id : void 0 : void 0] : void 0;
      this.addEnum(concept != null ? (_ref3 = concept.coreRepresentation) != null ? _ref3.enumeration : void 0 : void 0, target, structs.codelists);
      this.addEnum((_ref4 = comp.localRepresentation) != null ? _ref4.enumeration : void 0, target, structs.codelists);
      this.addTextFormat(concept != null ? (_ref5 = concept.coreRepresentation) != null ? _ref5.textFormat : void 0 : void 0, target);
      return this.addTextFormat((_ref6 = comp.localRepresentation) != null ? _ref6.textFormat : void 0, target);
    };

    StructureSpecificChecker.prototype.addDimensions = function(source, target, structs) {
      var comp, dim, key, _results;
      _results = [];
      for (key in source) {
        comp = source[key];
        if (!(comp.type !== 'timeDimension')) {
          continue;
        }
        this.log.debug("adding dimension " + key);
        dim = {};
        dim.type = 'string';
        dim.required = true;
        this.addFromRepresentation(comp, dim, structs);
        _results.push(target[key] = dim);
      }
      return _results;
    };

    StructureSpecificChecker.prototype.addAttributes = function(source, target, structs) {
      var comp, dim, key, _results;
      _results = [];
      for (key in source) {
        comp = source[key];
        if (!(comp.attributeRelationship.dimensions != null)) {
          continue;
        }
        this.log.debug("adding attribute " + key);
        dim = {};
        dim.type = 'string';
        if (comp.usageStatus === 'Mandatory') {
          dim.required = true;
        }
        this.addFromRepresentation(comp, dim, structs);
        _results.push(target[key] = dim);
      }
      return _results;
    };

    StructureSpecificChecker.prototype.addObsAttributes = function(source, target, structs) {
      var comp, dim, key, _results;
      _results = [];
      for (key in source) {
        comp = source[key];
        if (!(comp.attributeRelationship.primaryMeasure != null)) {
          continue;
        }
        this.log.debug("adding obs attribute " + key);
        dim = {};
        dim.type = 'array';
        if (comp.usageStatus === 'Mandatory') {
          dim.required = true;
        }
        dim.items = {};
        this.addFromRepresentation(comp, dim.items, structs);
        _results.push(target[key] = dim);
      }
      return _results;
    };

    StructureSpecificChecker.prototype.convertToJSONSchema = function(structs) {
      var schema;
      schema = {
        type: 'object',
        additionalProperties: false,
        properties: {
          seriesKey: {
            type: 'object',
            required: true,
            additionalProperties: false,
            properties: {}
          },
          attributes: {
            type: 'object',
            additionalProperties: false,
            properties: {}
          },
          obs: {
            type: 'object',
            additionalProperties: false,
            properties: {
              obsDimension: {
                type: 'array',
                required: true,
                items: {
                  type: 'string'
                }
              },
              obsValue: {
                type: 'array',
                items: {
                  type: 'number'
                }
              },
              attributes: {
                type: 'object',
                required: true,
                additionalProperties: false,
                properties: {}
              }
            }
          }
        }
      };
      this.addDimensions(structs.dataStructure.dimensionDescriptor, schema.properties.seriesKey.properties, structs);
      this.addAttributes(structs.dataStructure.attributeDescriptor, schema.properties.attributes.properties, structs);
      this.addObsAttributes(structs.dataStructure.attributeDescriptor, schema.properties.obs.properties.attributes.properties, structs);
      return this.schemas.series = schema;
    };

    StructureSpecificChecker.prototype.getSchema = function(schemaID, forJSON) {
      if (forJSON == null) {
        forJSON = false;
      }
      return this.schemas[schemaID];
    };

    StructureSpecificChecker.prototype.write = function(sdmxdata) {
      if (sdmxdata.type === 'header' && (sdmxdata.structures != null)) {
        this.convertToJSONSchema(sdmxdata.structures);
      }
      return StructureSpecificChecker.__super__.write.apply(this, arguments);
    };

    return StructureSpecificChecker;

  })(Checker);

  exports.StructureSpecificChecker = StructureSpecificChecker;

}).call(this);
