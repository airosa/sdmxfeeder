// Generated by CoffeeScript 1.3.1
(function() {
  var Log, SimpleRegistry, argv, async, createReadStream, createWriteStream, destinationPath, factory, findFiles, fs, getFileFormat, loadStructuresFromFiles, log, optimist, options, path, processInputFile, registry, sourcePath, start, zlib,
    _this = this;

  optimist = require('optimist');

  Log = require('log');

  async = require('async');

  fs = require('fs');

  path = require('path');

  zlib = require('zlib');

  SimpleRegistry = require('./registry/simpleRegistry').SimpleRegistry;

  factory = require('./pipe/pipeFactory');

  start = (new Date).getTime();

  argv = optimist.usage('Process a file.\nUsage: sdmxfeeder inputfile [outputfile]').demand(1)["default"]({
    level: 'INFO'
  }).describe({
    log: 'Log file name',
    level: 'Logging level'
  }).argv;

  log = new Log(Log[argv.level], process.stderr);

  log.info("Logging level is " + argv.level);

  log.info("http://github.com/airosa/sdmxfeeder v0.1.1");

  log.info("Starting to process");

  registry = new SimpleRegistry(log);

  sourcePath = argv._[0];

  destinationPath = argv._[1];

  options = {
    log: log,
    registry: registry
  };

  loadStructuresFromFiles = function(callback) {
    return fs.exists('./registry', function(exists) {
      if (exists) {
        return findFiles('./registry', function(err, dirPath, files) {
          var fileIterator;
          fileIterator = function(file, callback1) {
            var format, fullpath, pipe, source;
            fullpath = path.join(dirPath, file);
            format = getFileFormat(fullpath);
            source = createReadStream(fullpath, format);
            pipe = pipeFactory.build(['READ_' + format, 'CHECK', 'SUBMIT'], options);
            pipe.on('end', callback1);
            return pipe.pump(source);
          };
          return async.forEachSeries(files, fileIterator, callback);
        });
      } else {
        return callback();
      }
    });
  };

  processInputFile = function(callback) {
    var destination, formatIn, formatOut, gzipOut, pipe, pipes, source, unzip, _ref;
    formatIn = getFileFormat(sourcePath);
    pipes = ['READ_' + formatIn, 'CONVERT'];
    source = createReadStream(sourcePath, formatIn);
    if ((_ref = path.extname(sourcePath)) === '.gz') {
      unzip = zlib.createUnzip();
      source.pipe(unzip);
      source = unzip;
    }
    if (destinationPath != null) {
      formatOut = getFileFormat(destinationPath);
      destination = createWriteStream(destinationPath, formatOut);
      if (formatOut === 'ATOM') {
        pipes.push('SUBMIT');
        pipes.push('DECODE');
      }
      pipes.push('WRITE_' + formatOut);
      switch (path.extname(destinationPath)) {
        case '.gz':
          console.log('gz');
          gzipOut = zlib.createGzip();
          gzipOut.pipe(destination);
          destination = gzipOut;
      }
    }
    pipe = factory.build(pipes, options);
    if (destination != null) {
      destination.on('end', callback);
    } else {
      pipe.on('end', callback);
    }
    return pipe.pump(source, destination);
  };

  findFiles = function(path, callback) {
    log.info("Looking for files in directory " + path);
    return fs.realpath(path, function(err, resolvedPath) {
      if (err != null) {
        throw err;
      }
      return fs.readdir(resolvedPath, function(err, files) {
        if (err != null) {
          throw err;
        }
        return callback(err, resolvedPath, files);
      });
    });
  };

  createReadStream = function(fullpath, format) {
    var countTo10Mb, len, source;
    len = countTo10Mb = 0;
    start = (new Date).getTime();
    log.info("Source: " + fullpath);
    log.info("Source format: " + format);
    source = fs.createReadStream(fullpath);
    switch (format) {
      case 'EDI':
        source.setEncoding('ascii');
        break;
      case 'XML':
      case 'JSON':
        source.setEncoding('utf8');
    }
    source.on('close', function() {
      var diff;
      diff = ((new Date).getTime() - start) / 1000;
      log.info("Source closed: " + fullpath);
      return log.info("Read " + len + " bytes in " + diff + " seconds");
    });
    source.on('data', function(data) {
      var diff;
      len += data.length;
      countTo10Mb += data.length;
      if (countTo10Mb > 10000000) {
        diff = ((new Date).getTime() - start) / 1000;
        log.info("read " + len + " bytes in " + diff + " seconds");
        return countTo10Mb = 0;
      }
    });
    return source;
  };

  createWriteStream = function(fullpath, format) {
    var destination;
    log.info("Destination: " + fullpath);
    log.info("Destination format: " + format);
    destination = fs.createWriteStream(fullpath);
    destination.on('close', (function() {
      return log.info("Destination closed: " + fullpath);
    }));
    return destination;
  };

  getFileFormat = function(fullpath) {
    var pos, _ref;
    if ((_ref = path.extname(fullpath)) === '.gz') {
      pos = fullpath.length - path.extname(fullpath).length - 1;
      return getFileFormat(fullpath.slice(0, pos + 1 || 9e9));
    } else {
      return path.extname(fullpath).toUpperCase().slice(1);
    }
  };

  process.on('exit', function() {
    var diff;
    diff = ((new Date).getTime() - start) / 1000;
    return log.info("Finished processing in " + diff + "s");
  });

  process.on('uncaughtException', function(err) {
    return log.critical("" + err);
  });

  async.series([loadStructuresFromFiles, processInputFile]);

}).call(this);
