// Generated by CoffeeScript 1.3.1
(function() {
  var Log, SimpleRegistry, argv, async, createReadStream, createWriteStream, destinationPath, factory, findFiles, fs, getFileFormat, loadStructuresFromFiles, log, optimist, options, path, pipeFactory, processInputFile, registry, sourcePath, start,
    _this = this;

  optimist = require('optimist');

  Log = require('log');

  async = require('async');

  fs = require('fs');

  path = require('path');

  SimpleRegistry = require('./registry/simpleRegistry').SimpleRegistry;

  factory = require('./pipe/pipeFactory');

  start = (new Date).getTime();

  argv = optimist.usage('Process a SDMX file.\nUsage: sdmxfeeder inputfile [outputfile]').demand(1)["default"]({
    level: 'INFO'
  }).describe({
    log: 'Log file name',
    level: 'Logging level'
  }).argv;

  log = new Log(Log[argv.level], process.stderr);

  log.info("Logging level is " + argv.level);

  log.info("http://github.com/airosa/sdmxfeeder v0.1.1");

  log.info("Starting to process");

  registry = new SimpleRegistry(log);

  sourcePath = argv._[0];

  destinationPath = argv._[1];

  options = {
    log: log,
    registry: registry
  };

  pipeFactory = new factory.PipeFactory();

  loadStructuresFromFiles = function(callback) {
    return path.exists('./registry', function(exists) {
      if (exists) {
        return findFiles('./registry', function(err, dirPath, files) {
          var fileIterator;
          fileIterator = function(file, callback1) {
            var format, fullpath, pipe, source;
            fullpath = path.join(dirPath, file);
            format = getFileFormat(fullpath);
            source = createReadStream(fullpath, format);
            pipe = pipeFactory.build(['READ_' + format, 'CHECK', 'SUBMIT'], options);
            pipe.on('end', callback1);
            return pipe.pump(source);
          };
          return async.forEachSeries(files, fileIterator, callback);
        });
      } else {
        return callback();
      }
    });
  };

  processInputFile = function(callback) {
    var destination, formatIn, formatOut, pipe, pipes, source;
    formatIn = getFileFormat(sourcePath);
    pipes = ['READ_' + formatIn, 'CONVERT', 'CHECK'];
    source = createReadStream(sourcePath, formatIn);
    if (destinationPath != null) {
      formatOut = getFileFormat(destinationPath);
      destination = createWriteStream(destinationPath, formatOut);
      pipes.push('WRITE_' + formatOut);
    }
    pipe = pipeFactory.build(pipes, options);
    if (destination != null) {
      destination.on('end', callback);
    } else {
      pipe.on('end', callback);
    }
    return pipe.pump(source, destination);
  };

  findFiles = function(path, callback) {
    log.info("Looking for files in directory " + path);
    return fs.realpath(path, function(err, resolvedPath) {
      if (err != null) {
        throw err;
      }
      return fs.readdir(resolvedPath, function(err, files) {
        if (err != null) {
          throw err;
        }
        return callback(err, resolvedPath, files);
      });
    });
  };

  createReadStream = function(fullpath, format) {
    var countTo1Mb, len, source;
    len = countTo1Mb = 0;
    start = (new Date).getTime();
    log.info("Source: " + fullpath);
    log.info("Source format: " + format);
    source = fs.createReadStream(fullpath);
    source.setEncoding(format === 'EDI' ? 'ascii' : 'utf8');
    source.on('close', function() {
      var diff;
      diff = ((new Date).getTime() - start) / 1000;
      log.info("Source closed: " + fullpath);
      return log.info("Read " + len + " bytes in " + diff + " seconds");
    });
    source.on('data', function(data) {
      var diff;
      len += data.length;
      countTo1Mb += data.length;
      if (countTo1Mb > 1000000) {
        diff = ((new Date).getTime() - start) / 1000;
        log.info("" + fullpath + " read " + len + " bytes in " + diff + " seconds");
        countTo1Mb = 0;
        return start = (new Date).getTime();
      }
    });
    return source;
  };

  createWriteStream = function(fullpath, format) {
    var destination;
    log.info("Destination: " + fullpath);
    log.info("Destination format: " + format);
    destination = fs.createWriteStream(fullpath);
    destination.on('close', (function() {
      return log.info("Destination closed: " + fullpath);
    }));
    return destination;
  };

  getFileFormat = function(fullpath) {
    var format;
    return format = path.extname(fullpath).toUpperCase().slice(1);
  };

  process.on('exit', function() {
    var diff;
    diff = ((new Date).getTime() - start) / 1000;
    return log.info("Finished processing in " + diff + "s");
  });

  process.on('uncaughtException', function(err) {
    return log.critical("" + err);
  });

  async.series([loadStructuresFromFiles, processInputFile]);

}).call(this);
